{"batchcomplete": "", "query": {"pages": {"18935488": {"ns": 0, "pageid": 18935488, "revisions": [{"comment": "/* Reverse engineering for military applications */", "*": "'''Reverse engineering''' is the [[process (engineering)|process]] of discovering the technological principles of a device, object, or system through analysis of its structure, [[Function (engineering)|function]], and operation.<ref>{{cite book|authors=Eilam, Eldad & Chikofsky, Elliot J.|title=Reversing: secrets of reverse engineering|publisher=John Wiley & Sons|year=2007|isbn=978-0-7645-7481-8|page=3|url=http://books.google.com/books?id=K8vIf99UBYQC&pg=PA3}}</ref> It often involves taking something (e.g., a [[machine|mechanical device]], [[electronic component]], [[software]] program, or biological, chemical, or organic matter) apart and analyzing its workings in detail to be used in maintenance, or to try to make a new device or program that does the same thing without using or simply duplicating (without understanding) the original.\n\nReverse engineering has its origins in the analysis of hardware for commercial or military advantage.<ref>{{Cite journal |doi=10.1109/52.43044 |first=E. J. |last=Chikofsky |lastauthoramp=yes |first2=J. H., II |last2=Cross |title=Reverse Engineering and Design Recovery: A Taxonomy |journal=IEEE Software |volume=7 |issue=1 |pages=13\u201317 |year=1990}}</ref> The purpose is to deduce design decisions from end products with little or no additional knowledge about the procedures involved in the original production. The same techniques are subsequently being researched for application to legacy software systems, not for industrial or defence ends, but rather to replace incorrect, incomplete, or otherwise unavailable documentation.<ref>A Survey of Reverse Engineering and Program Comprehension. Michael L. Nelson, April 19, 1996, ODU CS 551 \u2013 Software Engineering Survey. Furthermore, reverse engineering concept is used to modify or change premade .dll files in an operating systems</ref>\n\n==Motivation==\nReasons for reverse engineering:\n* '''Interfacing'''. RE can be used when a system is required to interface to another system and how both systems would negotiate is to be established. Such requirements typically exist for [[interoperability]].\n* '''Military or commercial [[espionage]]'''. Learning about an enemy's or competitor's latest research by stealing or capturing a prototype and dismantling it. It may result in development of similar product.\n* '''Improve documentation shortcomings''' Reverse engineering can be done when documentation of a system for its design, production, operation or maintenance have shortcomings and original designers are not available to improve it. RE of software can provide the most current documentation necessary for understanding the most current state of a software system\n* '''Obsolescence''' [[Integrated circuit]]s often seem to have been designed on obsolete, proprietary systems, which means that the only way to incorporate the functionality into new technology is to reverse-engineer the existing chip and then re-design it.\n* '''Software Modernization'''. RE is generally needed in order to understand the 'as is' state of existing or legacy software in order to properly estimate the effort required to migrate system knowledge into a 'to be' state. Much of this may be driven by changing functional, compliance or security requirements.\n* '''Product Security Analysis.'''. To examine how a product works, what are specifications of its components, estimate costs and identify potential [[patent infringement]]. Acquiring sensitive data by disassembling and analysing the design of a system component.<ref name=rfc2828>Internet Engineering Task Force RFC 2828 Internet Security Glossary</ref>. Another intent may be to remove [[copy protection]], circumvention of access restrictions.\n* Creation of unlicensed/unapproved duplicates.\n* Academic/learning purposes. RE for learning purposes may be understand the key issues of an unsuccessful design and subsequently improve the design.\n* Competitive technical intelligence (understand what your competitor is actually doing, versus what they say they are doing).\n\n==Reverse engineering of machines==\nAs [[computer-aided design]] (CAD) has become more popular, reverse engineering has become a viable method to create a 3D virtual model of an existing physical part for use in 3D CAD, [[Computer-aided manufacturing|CAM]], [[computer-aided engineering|CAE]] or other software.<ref>{{cite journal|doi=10.1016/S0010-4485(96)00054-1|url=http://ralph.cs.cf.ac.uk/papers/Geometry/RE.pdf|title=Reverse engineering of geometric models?an introduction|year=1997|last1=Varady|first1=T|journal=Computer-Aided Design|volume=29|issue=4|pages=255\u2013268}}</ref> The reverse-engineering process involves measuring an object and then reconstructing it as a 3D model. The physical object can be measured using [[3D scanner|3D scanning]] technologies like [[coordinate-measuring machine|CMMs]], [[3d scanner#Triangulation|laser scanners]], [[3d scanner#Structured light|structured light digitizer]]s, or [[Industrial CT Scanning]] (computed tomography). The measured data alone, usually represented as a [[point cloud]], lacks topological information and is therefore often processed and modeled into a more usable format such as a triangular-faced mesh, a set of [[Nonuniform rational B-spline|NURBS]] surfaces, or a [[computer assisted design|CAD]] model.\n\nReverse engineering is also used by businesses to bring existing physical geometry into digital product development environments, to make a digital 3D record of their own products, or to assess competitors' products. It is used to analyse, for instance, how a product works, what it does, and what components it consists of, estimate costs, and identify potential [[patent]] infringement, etc.\n\n[[Value engineering]] is a related activity also used by businesses. It involves de-constructing and analysing products, but the objective is to find opportunities for cost cutting.\n\n==Reverse engineering of software==\nThe term ''reverse engineering'' as applied to software means different things to different people, prompting Chikofsky and Cross to write a paper researching the various uses and defining a [[taxonomy]]. From their paper, they state, \"Reverse engineering is the process of analyzing a subject system to create representations of the system at a higher level of abstraction.\"<ref> {{Cite journal \n| last1 = Chikofsky | first1 = E. J. \n| last2 = Cross | first2 = J. H. \n| doi = 10.1109/52.43044 \n| title = Reverse engineering and design recovery: A taxonomy \n| journal = IEEE Software \n| volume = 7 \n| pages = 13\u201317\n| year = 1990 \n\n| month = January\n| url = http://win.ua.ac.be/~lore/Research/Chikofsky1990-Taxonomy.pdf\n<!-- multiple other PDF copies are available if this link dies, check Google Scholar -->\n\n}}</ref> It can also be seen as \"going backwards through the development cycle\".<ref>{{cite book | last=Warden | first=R. | title=Software Reuse and Reverse Engineering in Practice | year=1992 | publisher=Chapman & Hall | location=London, England | pages=283\u2013305}}</ref> In this model, the output of the implementation phase (in source code form) is reverse-engineered back to the analysis phase, in an inversion of the traditional [[waterfall model]]. Reverse engineering is a process of examination only: the software system under consideration is not modified (which would make it [[reengineering (software)|re-engineering]]). [[Software anti-tamper]] technology is used to deter both reverse engineering and re-engineering of proprietary software and software-powered systems. In practice, two main types of reverse engineering emerge. In the first case, source code is already available for the software, but higher-level aspects of the program, perhaps poorly documented or documented but no longer valid, are discovered. In the second case, there is no source code available for the software, and any efforts towards discovering one possible source code for the software are regarded as reverse engineering. This second usage of the term is the one most people are familiar with. Reverse engineering of software can make use of the [[clean room design]] technique to avoid copyright infringement.\n\nOn a related note, [[black box testing]] in [[software engineering]] has a lot in common with reverse engineering. The tester usually has the [[application programming interface|API]], but their goals are to find bugs and undocumented features by bashing the product from outside.\n\nOther purposes of reverse engineering include security auditing, removal of copy protection (\"[[software cracking|cracking]]\"), circumvention of access restrictions often present in [[consumer electronics]], customization of [[embedded systems]] (such as engine management systems), in-house repairs or retrofits, enabling of additional features on low-cost \"crippled\" hardware (such as some graphics card chip-sets), or even mere satisfaction of curiosity.\n\n==Source code==\nA number of [[Unified Modeling Language|UML]] tools refer to the process of importing and analysing source code to generate UML diagrams as \"reverse engineering\". See [[List of UML tools]].\n\nAlthough UML is one approach to providing \"reverse engineering\" more recent advances in international standards activities have resulted in the development of the Knowledge Discovery Metamodel (KDM).  This standard delivers an ontology for the intermediate (or abstracted) representation of programming language constructs and their interrelationships.  An Object Management Group Standard (on its way to becoming an ISO standard as well), KDM has started to take hold in industry with the development of tools and analysis environments which can deliver the  extraction and analysis of source, binary, and byte code.  For source code analysis, KDM's granular standards' architecture enables the extraction of software system flows (data, control, & call maps), architectures, and business layer knowledge (rules, terms, process). The standard enables the use of a common data format (XMI) enabling the correlation of the various layers of system knowledge for either detailed analysis (e.g. root cause, impact) or derived analysis (e.g. business process extraction).  Although efforts to represent language constructs can be never-ending given the number of languages, the continuous evolution of software languages and the development of new languages, the standard does allow for the use of extensions to support the broad language set as well as evolution.  KDM is compatible with UML, BPMN, RDF and other standards enabling migration into other environments and thus leverage system knowledge for efforts such as software system transformation and enterprise business layer analysis.\n\n==Reverse engineering of protocols==\n\n[[Communications protocol|Protocols]] are sets of rules that describe message formats and how messages are exchanged (i.e., the protocol [[Finite-state machine|state-machine]]). Accordingly, the problem of protocol reverse-engineering can be partitioned into two subproblems; message format and state-machine reverse-engineering.\n\nThe message formats have traditionally been reverse-engineered through a tedious manual process, which involved analysis of how protocol implementations process messages, but recent research proposed a number of automatic solutions.<ref>W. Cui, J. Kannan, and H. J. Wang. Discoverer: Automatic protocol reverse engineering from network traces. In Proceedings of 16th USENIX Security Symposium on USENIX Security Symposium, pp. 1\u201314.</ref><ref>W. Cui, M. Peinado, K. Chen, H. J. Wang, and L. Ir\u00fan-Briz. Tupni: Automatic reverse engineering of input formats. In Proceedings of the 15th ACM Conference on Computer and Communications Security, pp. 391\u2013402. ACM, Oct 2008.</ref><ref name=\"M. Comparetti, G. Wondracek pages 110-125\">P. M. Comparetti, G. Wondracek, C. Kruegel, and E. Kirda. Prospex: Protocol specification extraction. In Proceedings of the 2009 30th IEEE Symposium on Security and Privacy, pp. 110\u2013125, Washington, 2009. IEEE Computer Society.</ref> Typically, these automatic approaches either group observed messages into clusters using various [[Cluster analysis|clustering analyses]], or emulate the protocol implementation tracing the message processing.\n\nThere has been less work on reverse-engineering of state-machines of protocols. In general, the protocol state-machines can be learned either through a process of [[offline learning]], which passively observes communication and attempts to build the most general state-machine accepting all observed sequences of messages, and [[online learning]], which allows interactive generation of probing sequences of messages and listening to responses to those probing sequences. In general, offline learning of small state-machines is known to be [[NP-complete]],<ref>{{cite journal|doi=10.1016/S0019-9958(78)90562-4|title=Complexity of automaton identification from given data|year=1978|last1=Gold|first1=E|journal=Information and Control|volume=37|issue=3|pages=302\u2013320 }}</ref> while online learning can be done in polynomial time.<ref>{{cite journal|author=D. Angluin|title= Learning regular sets from queries and counterexamples|doi=10.1016/0890-5401(87)90052-6|journal= Information and Computation|volume= 75|issue=2|pages=87\u2013106|year=1987}}</ref> An automatic offline approach has been demonstrated by Comparetti et al.<ref name=\"M. Comparetti, G. Wondracek pages 110-125\"/> and an online approach very recently by Cho et al.<ref>C.Y. Cho, D. Babic, R. Shin, and D. Song. [http://www.domagoj-babic.com/index.php/Pubs/CCS10botnets Inference and Analysis of Formal Models of Botnet Command and Control Protocols], 2010 ACM Conference on Computer and Communications Security.</ref>\n\nOther components of typical protocols, like encryption and hash functions, can be reverse-engineered automatically as well. Typically, the automatic approaches trace the execution of protocol implementations and try to detect buffers in memory holding unencrypted packets.<ref>[http://bitblaze.cs.berkeley.edu/papers/polyglot_ccs07_av.pdf Polyglot: automatic extraction of protocol message format using dynamic binary analysis]. J. Caballero, H. Yin, Z. Liang, and D. Song. Proceedings of the 14th ACM conference on Computer and communications security, p. 317-329.</ref>\n\n==Reverse engineering of integrated circuits/smart cards==\nReverse engineering is an invasive and destructive form of analyzing a smart card. The attacker grinds away layer by layer of the smart card and takes pictures with an [[electron microscope]]. With this technique, it is possible to reveal the complete hardware and software part of the smart card. The major problem for the attacker is to bring everything into the right order to find out how everything works. Engineers try to hide keys and operations by mixing up memory positions, for example, [[bus scrambling]].<ref>Wolfgang Rankl, Wolfgang Effing, Smart Card Handbook (2004)</ref><ref>T. Welz: [http://www.crypto.rub.de/its_seminar_ws0708.html Smart cards as methods for payment] (2008), Seminar ITS-Security Ruhr-Universit\u00e4t Bochum</ref>\nIn some cases, it is even possible to attach a probe to measure voltages while the smart card is still operational. Engineers employ sensors to detect and prevent this attack.<ref>David C. Musker: [http://www.jenkins.eu/articles-general/reverse-engineering.asp Protecting & Exploiting Intellectual Property in Electronics], IBC Conferences, 10 June 1998</ref> This attack is not very common because it requires a large investment in effort and special equipment that is generally only available to large chip manufacturers. Furthermore, the payoff from this attack is low since other security techniques are often employed such as shadow accounts.\n\n==Legality==\n== See also ==\n{{colbegin|3}}\n* [[Antikythera mechanism]]\n* [[Benchmarking]]\n* [[Bus analyzer]]\n* [[Chonda]]\n* [[Clean room design]]\n* [[coordinate-measuring machine|CMM]]\n* [[Code morphing]]\n* [[Connectix Virtual Game Station]]\n* [[Cryptanalysis]]\n* [[Decompiler]]\n* [[Digital Millennium Copyright Act]] (DMCA)\n* [[Forensic engineering]]\n* [[Industrial CT scanning]]\n* [[Interactive Disassembler]]\n* [[Knowledge Discovery Metamodel]]\n* [[3d scanner#Triangulation|Laser scanner]]\n* [[List of production topics]]\n* [[Logic analyzer]]\n* [[Paycheck (film)]]\n* [[Software archaeology]]\n* [[3d scanner#Structured light|Structured light digitizer]]\n* [[Value engineering]]\n{{colend}}\n\n== References ==\n{{Reflist|30em}}\n\n==Further reading==\n*{{Cite book |title=[[Reversing: Secrets of Reverse Engineering]] |last=Eilam |first=Eldad |year=2005 |publisher=[[Wiley Publishing]] |isbn=0-7645-7481-7 |page=595 }}\n*{{cite web |url=http://electronicdesign.com/Articles/Index.cfm?AD=1&ArticleID=11966 |author=James, Dick |title=Reverse Engineering Delivers Product Knowledge; Aids Technology Spread |accessdate=2009-02-03 |work=Electronic Design |publisher=Penton Media, Inc |date=January 19, 2006 }}\n*{{Cite book |title=Reverse Engineering \u2013 An Industrial Perspective |last=Raja |first=Vinesh |coauthors=Fernandes, Kiran J. |year=2008 |publisher = [[Springer Science+Business Media|Springer]] |isbn=978-1-84628-855-5 |page=242}}\n*{{cite web |url=http://ewh.ieee.org/r5/denver/sscs/References/2007_09_Torrance.pdf |author=Thumm, Mike |title=Talking Tactics |accessdate=2009-02-03 |work=IEEE 2007 Custom Integrated Circuits Conference (CICC) |publisher=IEEE, Inc |year=2007 }}\n*{{cite web |url=http://www.reversingproject.info |author=Cipresso, Teodoro |title=Software Reverse Engineering Education |accessdate=2009-08-22 |work=SJSU Master's Thesis |publisher=ProQuest UML |year=2009 }}\n\n==External links==\n{{wikibooks}}\n<!--======================== {{No more links}} ============================\n    | PLEASE BE CAUTIOUS IN ADDING MORE LINKS TO THIS ARTICLE. Wikipedia  |\n    | is not a collection of links nor should it be used for advertising. |\n    |                                                                     |\n    |           Excessive or inappropriate links WILL BE DELETED.         |\n    | See [[Wikipedia:External links]] & [[Wikipedia:Spam]] for details.  |\n    |                                                                     |\n    | If there are already plentiful links, please propose additions or   |\n    | replacements on this article's discussion page, or submit your link |\n    | to the relevant category at the Open Directory Project (dmoz.org)   |\n    | and link back to that category using the {{dmoz}} template.         |\n    ======================= {{No more links}} =============================-->\n*[http://www.npd-solutions.com/reoverview.html What Is Reverse Engineering]\n* [https://github.com/jcdutton/libbeauty An Open Source Reverse Engineering tool for Linux]\n* [http://revenge.berlios.de/ An Open Source Reverse Engineering tools and ideas for Linux]\n* [https://sourceforge.net/projects/javacalltracer/ Java Call Trace to UML Sequence Diagram] A reverse engineering tool for Java. This tool helps you to reverse engineer UML Sequence Diagram for your java program at runtime. It works well with both complex java programs (that have multiple threads) and J2EE applications deployed on Application Servers.\n* [http://case-tools.org/reverse_engineering.html CASE Tools for Reverse Code Engineering]\n* [http://www.imagix.com/links/reverse_engineering.html Additional tutorials, bibliographies and related sites] for reverse engineering of available source code.\n* [http://www.codeproject.com/Articles/30815/An-Anti-Reverse-Engineering-Guide Anti-Reverse Engineering Guide]\n\n{{Technology}}\n{{DEFAULTSORT:Reverse Engineering}}\n[[Category:Articles with inconsistent citation formats]]\n[[Category:Engineering concepts]]\n[[Category:Production and manufacturing]]\n[[Category:Computer security]]\n[[Category:Patent law]]\n\n[[ar:\u0647\u0646\u062f\u0633\u0629 \u0639\u0643\u0633\u064a\u0629]]\n[[ca:Enginyeria inversa]]\n[[cs:Reverzn\u00ed in\u017een\u00fdrstv\u00ed]]\n[[da:Reverse engineering]]\n[[de:Reverse Engineering]]\n[[es:Ingenier\u00eda inversa]]\n[[fa:\u0645\u0647\u0646\u062f\u0633\u06cc \u0645\u0639\u06a9\u0648\u0633]]\n[[fr:R\u00e9troing\u00e9nierie]]\n[[ko:\ub9ac\ubc84\uc2a4 \uc5d4\uc9c0\ub2c8\uc5b4\ub9c1]]\n[[it:Ingegneria inversa]]\n[[he:\u05d4\u05e0\u05d3\u05e1\u05d4 \u05d4\u05e4\u05d5\u05db\u05d4]]\n[[kn:\u0ca4\u0c82\u0ca4\u0ccd\u0cb0\u0c9c\u0ccd\u0c9e\u0cbe\u0ca8\u0ca6 \u0cae\u0cc2\u0cb2\u0ca4\u0ca4\u0ccd\u0cb5\u0ca6 \u0c86\u0cb5\u0cbf\u0cb7\u0ccd\u0c95\u0cbe\u0cb0 (\u0cb0\u0cbf\u0cb5\u0cb0\u0ccd\u0cb8\u0ccd \u0c87\u0c82\u0c9c\u0cbf\u0ca8\u0cbf\u0caf\u0cb0\u0cbf\u0c82\u0c97\u0ccd)]]\n[[ml:\u0d31\u0d3f\u0d35\u0d47\u0d34\u0d4d\u0d38\u0d4d\u200c \u0d0e\u0d1e\u0d4d\u0d1a\u0d3f\u0d28\u0d40\u0d2f\u0d31\u0d3f\u0d02\u0d17\u0d4d\u200c]]\n[[ms:Kejuruteraan undur]]\n[[nl:Reverse engineering]]\n[[ja:\u30ea\u30d0\u30fc\u30b9\u30a8\u30f3\u30b8\u30cb\u30a2\u30ea\u30f3\u30b0]]\n[[no:Reverse engineering]]\n[[pl:In\u017cynieria odwrotna]]\n[[pt:Engenharia reversa]]\n[[ro:Inginerie invers\u0103]]\n[[ru:\u041e\u0431\u0440\u0430\u0442\u043d\u0430\u044f \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0430]]\n[[fi:Takaisinmallinnus]]\n[[sr:\u041e\u0431\u0440\u043d\u0443\u0442\u0438 \u0438\u043d\u0436\u0435\u045a\u0435\u0440\u0438\u043d\u0433]]\n[[sv:Reverse engineering]]\n[[ta:\u0baa\u0bbf\u0ba9\u0bcd\u0ba9\u0bcb\u0b95\u0bcd\u0b95\u0bc1\u0baa\u0bcd \u0baa\u0bca\u0bb1\u0bbf\u0baf\u0bbf\u0baf\u0bb2\u0bcd]]\n[[th:\u0e27\u0e34\u0e28\u0e27\u0e01\u0e23\u0e23\u0e21\u0e1c\u0e31\u0e19\u0e01\u0e25\u0e31\u0e1a]]\n[[tr:Tersine m\u00fchendislik]]\n[[uk:\u0417\u0432\u043e\u0440\u043e\u0442\u043d\u0430 \u0440\u043e\u0437\u0440\u043e\u0431\u043a\u0430]]\n[[vi:K\u1ef9 ngh\u1ec7 \u0111\u1ea3o ng\u01b0\u1ee3c]]\n[[zh:\u9006\u5411\u5de5\u7a0b]]", "timestamp": "2012-08-28T20:01:15Z", "contentformat": "text/x-wiki", "revid": 509655819, "contentmodel": "wikitext", "user": "SHWZ", "parentid": 509655782}], "title": "Reverse engineering"}}}}